# community牛客社区项目



#### 1 技术点：

前端:thymeleaf 动态引擎框架

后端：SpringBoot，Mybatis ，MySQL，Redis数据库



#### 2 功能模块

**首页模块**： 分页显示所有的帖子信息。 重点主要在于tymeleaf模板引擎的使用，如何将模型MODEL中绑定的参数交给视图进行动态渲染

**用户账号注册与激活**：

1. 邮件发送工具类，SpringBoot整合SpringMail，使用QQ邮箱作为发件方，利用tymeleaf邮件模板，发送HTML邮件；
2. 用户注册账号，发送一封激活邮件
3. 用户点击激活邮件，激活注册的账号

**账号登录，退出模块**：

``【验证用户信息及验证码进行登录】``

1. 整合Kapatcha，实现生成动态验证码

2. 验证账号，密码，验证码；验证成功后生成登录凭证，验证失败后跳转回登录页面

3. 账号退出时，将登录凭证修改为失效状态，跳转到用户首页、

**显示首页信息**

```txt
登录之后显示正确显示用户信息
使用LoginInterceptor进行拦截，判断用户是否正常登录
显示在页眉的信息会根据登录与否显示的不同。登录之前需要显示注册、登录界面，登录之后显示用户头像，消息等信息
由于http请求的无状态性，多个连续的请求需要保持一致性，所以以为着每个请求都需要判断用户是否登录与否。
此处用到了拦截器对所有的请求进行的统一的处理。【拦截器的主要使用包括两个步骤，实现HandlerInterceptor类，注册Interceptor】
```

在本该功能模块中实现的具体步骤为：

1. 在请求开始时查询登录用户; 【在进入之前执行preHandle】 
2. 本次请求中持有本次用户信息; 【在请求结束前使用的是同一个线程，可将持有的用户信息存入到ThreadLocal中】
3. 在模板视图中显示用户信息; 【postHandle】
4. 在模板视图渲染后显示用户信息; 【afterCompletion】



 **设置用户信息**

1 切换到用户设置页面

2 上传用户头像并更新数据库中用户头像信息【POST请求】

3 修改用戶密码



**检查用户登录状态**

```text
某些功能页面的访问需要登录之后进行访问，需要判断请求是否是成功登录的。【某些指定的功能界面通过自定义注解定义，标注了该注解的方法必须是在登录下进行】
通过拦截器的功能实现。判断是否标注了注解通过反射的方式来判断。
```

**过滤敏感词**

**用戶增加帖子**

使用ajax发送异步请求，使得浏览器不刷新就能动态地显示增量数据。

**查詢帖子詳情**

每一篇帖子都链接到帖子详情的接口，使用thymeleaf动态地替换，并展现帖子的信息【作者头像，作者名字，帖子标题，帖子内容，帖子发布时间】

**查詢帖子评论信息**

分页查询帖子的评论信息，在查询帖子详情的基础上拓展Thymeleaf处理的数据，主要难点在于thymeleaf处理绑定到Model上的数据

**增加帖子评论**

数据层：增加评论，修改评论帖子的评论数

业务层：实现增加评论和增加评论对象的评论数功能

表现层：处理增加评论的请求，前台处理添加评论的表单，处理数据后重定向到帖子详情页面，刷新带出新添加的评论信息 

由于帖子的增加和帖子数的增加数据库上的操作要求原子性，所以该功能将用上**事务**来解决事务不一致出现的问题

**私信列表**

查询当前用户的会话列表，支持分页显示，每个会话之间显示一条最新的私信

该功能模块强调数据Mapper的编写

```txt
分页用户的查询消息列表【针对每个会话，只返回一条最新的私信】
查询所有会话数目【用于分页】
查询会话的所有私信列表
根据会话id查询当前会话包含的所有私信数目【用于支持分页】
查询当前用户未读的会话【未读私信数】
```

**统一异常管理**



**统一记录日志log**
可以将模块中的记录日志功能与业务功能抽离，并将其封装成一个单独的切面，可织入到业务逻辑中【切点匹配的连接点处】，达到代码的耦合度降低


```text
涉及到的知识点：
1面向切面编程的思想【AOP】
2切面的相关术语
切面，切点，连接点，目标对象，连接点，织入【织入的时间点】
3实现的基本原理 AspectJ，通过实现代理对象，增强目标切面的功能。目标对象存在接口时，通过反射实现动态代理，不存在时通过cglib动态代理实现
```



**用户点赞**
用户可在帖子详情页面对帖子，评论进行点赞。操作一次点赞成功，再次操作时取消点赞
使用ajax异步请求，动态地更新赞的个数
赞数目更新频率比较高而且要实时，存在关系型数据库会被高频读写，导致表的io高。读内存比硬盘快，因此赞信息存储到redis数据库中。采用set作为存储赞的信息 like:entity:[entityType]:[entityId] 



**我收到的赞**

重构点赞功能，以like:user:[userId]为key,存储数据类型为String,点赞时，同时记录用户收到的点赞数据量。increment(key)，decrement(key)

因为涉及到多个redis命令的执行，这里采用redis事务进行处理，

开发个人主页，显示用户相关信息【这里显示用户基本信息，用户收到的赞的数目，关注的人总数与粉丝总数】



**==用户关注与取消关注 【重点】==**

任然采用redis存储用户关注的对象以及这个被关注的对象所有关注的人信息，实际中，关注是有先后动作的，所以采用ZSet存储【用户/被关注对象信息 以及对象的分值，用时间作为分值】这样可以对所有member按照时间进行排序

这里强调，用户关注不仅仅关注的是人，还可以关注帖子，题目等其他实体，因此在设计存储的key时需要注意可变性！

``follower:关注的人``   key=follower:entityId:entityType ZSet(UserId,time) ，被关注对象的粉丝信息，存储用户id以及关注对象关注的时间

``folllowee:关注的实体``   key=followee:userId:entityType ZSet(EntityId,time)   ，用户关注的对象，存储关注的实体id以及开始关注的时间

A关注了B，A是B的follower(粉丝)，B是A的followee(关注对象)



**关注列表与粉丝列表**

根据上一个功能而言，可以查询用户关注列表与粉丝列表，支持分页功能。数据是从redis数据库中取出



**==登录功能优化 【重点】==**

**验证码:**

验证码需要频繁的访问与刷新，对性能要求过高；验证码存储并不是永久的存储在数据库中，可对此设置过期时间，过期后自动失效

**登录凭证：**

每次请求都必须要要经过拦截器去验证登录凭证是否有效，此种数据高频被访问，可以考虑到存到redis数据库中

**缓存用户信息：**

处理每次请求，必须经过数据库查询当前用户的信息，因此可将用户信息缓存到redis数据库中

用戶的获取分为3步

```text
1 优先从redis缓存中获取用户
2 数据更新后需要删除原来的缓存
3 获得用户缓存为null时，插入用戶緩存
```





